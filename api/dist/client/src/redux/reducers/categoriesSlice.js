"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const toolkit_1 = require("@reduxjs/toolkit");
const initialState = {
    categories: [],
    status: "idle",
};
exports.fetchCategories = toolkit_1.createAsyncThunk("getCategories", () => __awaiter(void 0, void 0, void 0, function* () {
    const response = yield fetch(process.env.REACT_APP_SERVER_URL + "/category", {
        method: "GET",
        headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            "Access-Control-Allow-Credentials": "true",
        },
    });
    if (response.status === 201) {
        const res = yield response.json();
        return res.body.result;
    }
}));
exports.categoriesSlice = toolkit_1.createSlice({
    name: "categorySlice",
    initialState: initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {},
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder.addCase(exports.fetchCategories.pending, (state) => {
            state.categories = [];
            state.status = "loading";
        });
        builder.addCase(exports.fetchCategories.rejected, (state) => {
            state.categories = [];
            state.status = "failed";
        });
        builder.addCase(exports.fetchCategories.fulfilled, (state, action) => {
            state.status = "fullfilled";
            state.categories = action.payload;
            return state;
        });
        builder.addDefaultCase(() => { });
    },
});
// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
exports.selectCategoryItems = (state) => state.categories;
// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
_a = exports.categoriesSlice.actions;
exports.default = exports.categoriesSlice.reducer;
//# sourceMappingURL=categoriesSlice.js.map